substitutions:
  name: raspiaudio-radio
  friendly_name: Raspiaudio Radio
  #image_path: "https://github.com/RASPIAUDIO/muse-radio-voice-satellite/raw/main/images/"
  image_path: "http://xx.xx.xx.xx/RASPIAUDIO/muse-radio-voice-satellite/main/images/"



esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.2.0
  name_add_mac_suffix: false
  project:
    name: raspiaudio.voice-assistant
    version: "2025.3.1"
  on_boot:
    - priority: 800
      then:
        - light.turn_off: screen_backlight
        - wait_until:
            condition:
              lambda: return id(myDisplay).is_ready();
            timeout: 3s
        - if:
            condition:
              lambda: return id(myDisplay).is_ready();
            then:
              - lambda: |-
                    id(myDisplay).show_page(logoP);
                    id(myDisplay).update();
              - light.turn_on: screen_backlight
            else:
              - logger.log: "Display not ready during boot splash"
    - priority: -100
      then:
        - output.turn_off: dac_mute
        - light.turn_on:
            id: screen_backlight
            brightness: 100%
        - lambda: |-
                id(lightTO) = 0;
                id(phase) = 0;
        - media_player.volume_set:
                id: speaker_media_player
                volume: !lambda return id(Vol);
        - script.execute: reset_display
#      - lambda: id(my_es8388).set_volume(0.0);
        - micro_wake_word.start:


esp32:
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"

preferences:
  flash_write_interval: 5s

psram:
  mode: octal
  speed: 80MHz

external_components:
  - source: github://RASPIAUDIO/esphomeRadio@main
    components: [es8388]
    refresh: 0s

api:
# on_client_connected:
#    - script.execute: reset_display
#  on_client_disconnected:
#    - script.execute: reset_display

logger:
  level: INFO
  logs:
    sensor: WARN

web_server:
  include_internal: True
  version: 3

wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
    - ssid: !secret wifi_ssid_1
      password: !secret wifi_password
#  ssid: xxxxx
#  password: yyyyy
#  power_save_mode: none
  ap:
     ssid: "Raspiaudio-radio"
     password: "12345678"

ota:
  - platform: esphome
    id: ota_esphome
  - platform: http_request
    id: ota_http_request


update:
  - platform: http_request
    id: update_http_request
    name: Firmware
#    source: https://raw.githubusercontent.com/RASPIAUDIO/raspiaudio.github.io/main/MuseRadio/Homeassistant/manifest_update.json
    source: https://raw.githubusercontent.com/RASPIAUDIO/muse-radio-voice-satellite/main/manifest_update.json

http_request:

captive_portal:

improv_serial:

remote_receiver:
  id: ir_receiver
  pin:
    number: GPIO47
    inverted: true
  dump: nec
  on_nec:
    then:
      - if:
          condition:
            lambda: 'return x.command == 0xBF40;'
          then:
            - logger.log: "IR volume up"
            - script.execute:
                id: adjust_volume
                delta: 0.02
      - if:
          condition:
            lambda: 'return x.command == 0xB748;'
          then:
            - logger.log: "IR volume down"
            - script.execute:
                id: adjust_volume
                delta: -0.02
      - if:
          condition:
            lambda: 'return((x.command == 0xFE01) && (x.address == 0xFE01));'
          then:
            - logger.log: "IR mute"
            - script.execute: mute_unmute
      - if:
          condition:
            lambda: 'return((x.command == 0xF609) && (x.address == 0xFE01));'
          then:
            - logger.log: "IR ret"
            - script.execute: go_assist
      - if:
          condition:
            lambda: 'return((x.command == 0xFF00) && (x.address == 0xFE01));'
          then:
            - logger.log: "IR reset"
            - script.execute: go_reset

es8388:
#  id: my_es8388

i2c:
  id: codec_bus
  scl: GPIO11
  sda: GPIO18
  scan: true
i2c_device:
  id: my_es8388
  address: 0x10

spi:
  - id: spi_bus0
    clk_pin: GPIO12
    mosi_pin: GPIO8
    # miso_pin: GPIOXX
    interface: hardware

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: GPIO16
    i2s_bclk_pin: GPIO5
    i2s_mclk_pin: GPIO0

microphone:
  - platform: i2s_audio
    id: radio_mic
    sample_rate: 16000
    i2s_din_pin: GPIO4
    bits_per_sample: 16bit
    adc_type: external


speaker:
  - platform: i2s_audio
    id: radio_speaker
    i2s_dout_pin: GPIO17
    dac_type: external
    sample_rate: 48000
    bits_per_sample: 16bit
    channel: stereo
    buffer_duration: 100ms



media_player:
  - platform: speaker
    name: None
    id: speaker_media_player
#    volume_min: 0.5
#    volume_max: 0.8
#   internal: false
#   task_stack_in_psram: true
    announcement_pipeline:
      speaker: radio_speaker
      format: WAV
      sample_rate: 48000
      num_channels: 1
    files:
      - id: little_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac

    on_announcement:
      - if:
          condition:
            lambda: 'return(id(phase) != 2);'
          then:
            - lambda: |-
                id(lightTO) = 0;
                if (id(phase) == 1) {
                  id(phase) = 2;
                  id(external_player).execute();
                }
            - if:
                condition:
                  lambda: 'return id(auto_mute_active);'
                then:
                  - script.execute: mute_off
      - micro_wake_word.stop:

    on_idle:
      - wait_until:
         and:
          - not:
              media_player.is_announcing:
          - not:
              voice_assistant.is_running:
      - if:
          condition:
              lambda: 'return(id(phase) == 4);'
          then:
            - lambda: |-
                  id(phase) = 1;
            - script.execute: reset_display
      - if:
          condition:
               lambda: 'return(id(phase) == 2);'
          then:
            - lambda: |-
                  id(phase) = 1;
            - script.execute: reset_display

micro_wake_word:
  id: mww
  microphone: radio_mic
  stop_after_detection: false
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop
      internal: true
  on_wake_word_detected:
    - light.turn_on:
        id: screen_backlight
        brightness: 100%
        effect: none
    - voice_assistant.start:
        wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone: radio_mic
  media_player: speaker_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 2
  auto_gain: 31dBFS
  volume_multiplier: 2.0
  on_listening:
    - logger.log: "listening 3 => phase"
    - micro_wake_word.stop:
    - light.turn_on:
        id: screen_backlight
        brightness: 100%
        effect: none
    - lambda: |-
        id(phase) = 3;

    - script.execute: reset_display

  on_stt_end:
    - text_sensor.template.publish:
        id: text_request
        state: !lambda return x;

  on_tts_start:
    - logger.log: "answering  4 => phase"
    - text_sensor.template.publish:
        id: text_response
        state: !lambda return x;
    - light.turn_on:
        id: screen_backlight
        brightness: 100%
        effect: none
    - lambda: |-
        id(phase) = 4;
    - script.execute: reset_display


  on_end:
    - wait_until:
        and:
          - not:
              media_player.is_announcing:
          - not:
              voice_assistant.is_running:
    - if:
        condition:
          lambda: 'return(id(phase) != 1);'
        then:
          - lambda: id(phase) = 1;
          - script.execute: reset_display



  on_error:
    - logger.log: "ERROR!!!!!!!!!!!!!!!!"
    - light.turn_on:
        id: screen_backlight
        brightness: 100%
        effect: none
    - delay: 1s
    - lambda: id(phase) = 1;
    - script.execute: reset_display


#####################
# Internal Components
output:
  - platform: gpio
    id: dac_mute
    pin:
      number: GPIO46
      inverted: true
      mode:
        output: true
      ignore_strapping_warning: true

  - platform: ledc
    pin:
      number: GPIO41
      mode:
        output: true
    id: screen_backlight_pin

light:
  - platform: monochromatic
    output: screen_backlight_pin
    id: screen_backlight
    name: Screen Backlight
    #restore_mode: ALWAYS_ON

globals:
  - id: lightTO
    type: int
    initial_value: '0'
  - id: Vol
    type: float
    initial_value: '0.6'
    restore_value: true
  - id: phase
    type: int
    initial_value: '0'
  - id: mute
    type: bool
    initial_value: 'false'
  - id: mic_muted
    type: bool
    initial_value: 'false'
  - id: auto_mute_active
    type: bool
    initial_value: 'false'
  - id: volume_display_active
    type: bool
    initial_value: 'false'
  - id: volume_display_timer
    type: int
    initial_value: '0'


interval:
  - interval: 1sec
    then:

      - if:
          condition:
            and:
              - light.is_on: screen_backlight
              - lambda: 'return id(lightTO) < 60;'
          then:
            - lambda: id(lightTO)++;
          else:
            - lambda: id(lightTO) = 0;
            - light.turn_off: screen_backlight
      - if:
          condition:
            lambda: 'return id(volume_display_active);'
          then:
            - if:
                condition:
                  lambda: 'return id(volume_display_timer) >= 3;'
                then:
                  - lambda: |-
                      id(volume_display_active) = false;
                      id(volume_display_timer) = 0;
                      if (id(myDisplay).is_ready()) {
                        id(myDisplay).update();
                      }
                else:
                  - lambda: id(volume_display_timer)++;
      - if:
          condition:
            and:
              - lambda: 'return id(phase) == 0;'
              - not:
                  light.is_on: screen_backlight
          then:
            - light.turn_on: screen_backlight


image:
  - file: "${image_path}Raspiaudio.png"
    id: raspiIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}WFWW.png"
    id: WFWWIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}W.png"
    id: WIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}LISTEN.png"
    id: LIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}ANSWER.png"
    id: AIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}mute_mic.png"
    id: muteMicIm
    resize: 320x240
    type: RGB
  - file:  "${image_path}mute_speaker.png"
    id: muteSpeakerIm
    resize: 320x240
    type: RGB

font:
  - file:
      type: gfonts
      family: Figtree
      weight: 300
    id: font_request
    size: 15
  - file:
      type: gfonts
      family: Figtree
      weight: 300
    id: font_response
    size: 15
  - file:
      type: gfonts
      family: Figtree
      weight: 300
    id: font_battery_small
    size: 9

color:
  - id: green
    hex: '75D15F'
  - id: red
    hex: 'FF3131'
  - id: blue
    hex: '47B7E9'
  - id: amber
    hex: 'FBAB35'
  - id: lime
    hex: '20FC30'
  - id: pink
    hex: 'D92BBC'
  - id: yellow
    hex: 'FFC000'
  - id: black
    hex: '000000'
  - id: white
    hex: 'ffffff'
  - id: purple
    hex: '73264D'
  - id: light_blue
    hex: 'CFE2F3'
  - id: bg_blue
    hex: '032341'
  - id: bg_purple
    hex: '301020'
  - id: bg_green
    hex: '05350B'
  - id: bg_red
    hex: '3C0000'
  - id: bg_pink
    hex: '61034D'
  - id: bg_charcoal
    hex: '323232'
  - id: bg_brown
    hex: '41220D'
  - id: bg_grey
    hex: '4F4F4F'

display:
  - id: myDisplay
    platform: ili9xxx
    spi_id: spi_bus0
    model: ST7789V
    cs_pin: GPIO40
    dc_pin: GPIO39
    reset_pin: GPIO9
    invert_colors: true
    rotation: 90
    update_interval: never
    auto_clear_enabled: false
    pages:
        - id: logoP
          lambda: |-
            it.image(0, 0, id(raspiIm));
            auto draw_volume_bar = [&]() {
              if (!id(volume_display_active)) {
                return;
              }
              float display_volume = id(Vol);
              if (id(mute) || id(auto_mute_active)) {
                display_volume = 0.0f;
              }
              if (display_volume < 0.0f) {
                display_volume = 0.0f;
              }
              if (display_volume > 1.0f) {
                display_volume = 1.0f;
              }
              const int gauge_height = 18;
              const int margin = 3;
              const int display_width = it.get_width();
              const int display_height = it.get_height();
              if (display_width <= margin * 2 || display_height <= gauge_height) {
                return;
              }
              const int gauge_y = display_height - gauge_height;
              const int inner_width = display_width - margin * 2;
              const int inner_height = gauge_height - margin * 2;
              int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
              if (filled_width > inner_width) {
                filled_width = inner_width;
              } else if (filled_width < 0) {
                filled_width = 0;
              }
              it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
              if (inner_height > 0) {
                if (filled_width > 0) {
                  auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                  it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                }
                it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
              }
            };
            draw_volume_bar();
        - id: waitingP
          lambda: |-
            it.image(0, 0, id(WFWWIm));
            auto draw_volume_bar = [&]() {
              if (!id(volume_display_active)) {
                return;
              }
              float display_volume = id(Vol);
              if (id(mute) || id(auto_mute_active)) {
                display_volume = 0.0f;
              }
              if (display_volume < 0.0f) {
                display_volume = 0.0f;
              }
              if (display_volume > 1.0f) {
                display_volume = 1.0f;
              }
              const int gauge_height = 18;
              const int margin = 3;
              const int display_width = it.get_width();
              const int display_height = it.get_height();
              if (display_width <= margin * 2 || display_height <= gauge_height) {
                return;
              }
              const int gauge_y = display_height - gauge_height;
              const int inner_width = display_width - margin * 2;
              const int inner_height = gauge_height - margin * 2;
              int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
              if (filled_width > inner_width) {
                filled_width = inner_width;
              } else if (filled_width < 0) {
                filled_width = 0;
              }
              it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
              if (inner_height > 0) {
                if (filled_width > 0) {
                  auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                  it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                }
                it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
              }
            };
            auto draw_battery_icon = [&]() {
              const int margin = 4;
              const int icon_width = 34;
              const int icon_height = 14;
              const int cap_width = 4;
              const int vertical_offset = 2;
              const int display_width = it.get_width();
              if (display_width <= icon_width + cap_width + margin * 2) {
                return;
              }
              const int x = display_width - icon_width - cap_width - margin;
              const int y = margin + vertical_offset;
              const int cap_height = icon_height / 2;
              it.rectangle(x, y, icon_width, icon_height, id(black));
              it.filled_rectangle(x + icon_width, y + (icon_height - cap_height) / 2, cap_width, cap_height, id(black));
              const int inner_width = icon_width - 4;
              const int inner_height = icon_height - 4;
              it.filled_rectangle(x + 2, y + 2, inner_width, inner_height, id(bg_charcoal));
              if (!id(battery_percent).has_state()) {
                return;
              }
              float percent = id(battery_percent).state;
              if (percent < 0.0f) {
                percent = 0.0f;
              }
              if (percent > 100.0f) {
                percent = 100.0f;
              }
              auto level_color = id(lime);
              if (percent < 20.0f) {
                level_color = id(red);
              } else if (percent < 50.0f) {
                level_color = id(amber);
              }
              int fill_width = static_cast<int>(inner_width * (percent / 100.0f) + 0.5f);
              if (fill_width > inner_width) {
                fill_width = inner_width;
              } else if (fill_width < 0) {
                fill_width = 0;
              }
              if (fill_width > 0) {
                it.filled_rectangle(x + 2, y + 2, fill_width, inner_height, level_color);
              }
              it.printf(x + icon_width / 2, y + icon_height / 2 + 1, id(font_battery_small), id(black), TextAlign::CENTER, "%.0f%%", percent);
            };
 
            draw_volume_bar();
            draw_battery_icon();
        - id: waitingBP
          lambda: |-
            it.image(0, 0, id(WIm));
            auto draw_volume_bar = [&]() {
              if (!id(volume_display_active)) {
                return;
              }
              float display_volume = id(Vol);
              if (id(mute) || id(auto_mute_active)) {
                display_volume = 0.0f;
              }
              if (display_volume < 0.0f) {
                display_volume = 0.0f;
              }
              if (display_volume > 1.0f) {
                display_volume = 1.0f;
              }
              const int gauge_height = 18;
              const int margin = 3;
              const int display_width = it.get_width();
              const int display_height = it.get_height();
              if (display_width <= margin * 2 || display_height <= gauge_height) {
                return;
              }
              const int gauge_y = display_height - gauge_height;
              const int inner_width = display_width - margin * 2;
              const int inner_height = gauge_height - margin * 2;
              int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
              if (filled_width > inner_width) {
                filled_width = inner_width;
              } else if (filled_width < 0) {
                filled_width = 0;
              }
              it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
              if (inner_height > 0) {
                if (filled_width > 0) {
                  auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                  it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                }
                it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
              }
            };
            auto draw_battery_icon = [&]() {
              const int margin = 4;
              const int icon_width = 34;
              const int icon_height = 14;
              const int cap_width = 4;
              const int vertical_offset = 2;
              const int display_width = it.get_width();
              if (display_width <= icon_width + cap_width + margin * 2) {
                return;
              }
              const int x = display_width - icon_width - cap_width - margin;
              const int y = margin + vertical_offset;
              const int cap_height = icon_height / 2;
              it.rectangle(x, y, icon_width, icon_height, id(black));
              it.filled_rectangle(x + icon_width, y + (icon_height - cap_height) / 2, cap_width, cap_height, id(black));
              const int inner_width = icon_width - 4;
              const int inner_height = icon_height - 4;
              it.filled_rectangle(x + 2, y + 2, inner_width, inner_height, id(bg_charcoal));
              if (!id(battery_percent).has_state()) {
                return;
              }
              float percent = id(battery_percent).state;
              if (percent < 0.0f) {
                percent = 0.0f;
              }
              if (percent > 100.0f) {
                percent = 100.0f;
              }
              auto level_color = id(lime);
              if (percent < 20.0f) {
                level_color = id(red);
              } else if (percent < 50.0f) {
                level_color = id(amber);
              }
              int fill_width = static_cast<int>(inner_width * (percent / 100.0f) + 0.5f);
              if (fill_width > inner_width) {
                fill_width = inner_width;
              } else if (fill_width < 0) {
                fill_width = 0;
              }
              if (fill_width > 0) {
                it.filled_rectangle(x + 2, y + 2, fill_width, inner_height, level_color);
              }
              it.printf(x + icon_width / 2, y + icon_height / 2 + 1, id(font_battery_small), id(black), TextAlign::CENTER, "%.0f%%", percent);
            };

            
            auto draw_speaker_icon = [&]() {
              const int margin = 4;
              const int icon_width = 20;
              const int icon_height = 20;
              const int vertical_offset = 2;
              const int horizontal_offset = 4;
              int t = 1;
              if (it.get_width() <= icon_width + margin * 2) {
                return;
              }
              const int x = margin + horizontal_offset;
              const int y = margin + vertical_offset;
              const bool is_muted = id(mute) && !id(auto_mute_active);
              auto symbol_color = is_muted ? id(red) : id(green);

              it.rectangle(x-t, y+icon_height/4-t, icon_width, icon_height/2+t+t, id(black));
              it.triangle(x, y+icon_height/2, x+icon_width+t, y-t, x+icon_width+t, y+icon_height+t,id(black));   
              t = 2;      
              it.rectangle(x-t, y+icon_height/4-t, icon_width, icon_height/2+t+t, id(black));
              it.triangle(x, y+icon_height/2, x+icon_width+t, y-t, x+icon_width+t, y+icon_height+t,id(black));                     
              it.filled_rectangle(x, y+icon_height/4, icon_width, icon_height/2, symbol_color);
              it.filled_triangle(x, y+icon_height/2, x+icon_width, y, x+icon_width, y+icon_height,symbol_color); 
              it.line(x+icon_width/2, y+icon_height/4, x+icon_width/2, y+icon_height*3/4, id(black));
            };            
            
            draw_volume_bar();
            draw_speaker_icon();
            draw_battery_icon();           
        - id: listeningP
          lambda: |-
              it.image(0, 0, id(LIm));
              auto draw_volume_bar = [&]() {
                if (!id(volume_display_active)) {
                  return;
                }
                float display_volume = id(Vol);
                if (id(mute) || id(auto_mute_active)) {
                  display_volume = 0.0f;
                }
                if (display_volume < 0.0f) {
                  display_volume = 0.0f;
                }
                if (display_volume > 1.0f) {
                  display_volume = 1.0f;
                }
                const int gauge_height = 18;
                const int margin = 3;
                const int display_width = it.get_width();
                const int display_height = it.get_height();
                if (display_width <= margin * 2 || display_height <= gauge_height) {
                  return;
                }
                const int gauge_y = display_height - gauge_height;
                const int inner_width = display_width - margin * 2;
                const int inner_height = gauge_height - margin * 2;
                int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
                if (filled_width > inner_width) {
                  filled_width = inner_width;
                } else if (filled_width < 0) {
                  filled_width = 0;
                }
                it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
                if (inner_height > 0) {
                  if (filled_width > 0) {
                    auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                    it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                  }
                  it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
                }
              };
              auto draw_battery_icon = [&]() {
                const int margin = 4;
                const int icon_width = 34;
                const int icon_height = 14;
                const int cap_width = 4;
                const int vertical_offset = 2;
                const int display_width = it.get_width();
                if (display_width <= icon_width + cap_width + margin * 2) {
                  return;
                }
                const int x = display_width - icon_width - cap_width - margin;
                const int y = margin + vertical_offset;
                const int cap_height = icon_height / 2;
                it.rectangle(x, y, icon_width, icon_height, id(black));
                it.filled_rectangle(x + icon_width, y + (icon_height - cap_height) / 2, cap_width, cap_height, id(black));
                const int inner_width = icon_width - 4;
                const int inner_height = icon_height - 4;
                it.filled_rectangle(x + 2, y + 2, inner_width, inner_height, id(bg_charcoal));
                if (!id(battery_percent).has_state()) {
                  return;
                }
                float percent = id(battery_percent).state;
                if (percent < 0.0f) {
                  percent = 0.0f;
                }
                if (percent > 100.0f) {
                  percent = 100.0f;
                }
                auto level_color = id(lime);
                if (percent < 20.0f) {
                  level_color = id(red);
                } else if (percent < 50.0f) {
                  level_color = id(amber);
                }
                int fill_width = static_cast<int>(inner_width * (percent / 100.0f) + 0.5f);
                if (fill_width > inner_width) {
                  fill_width = inner_width;
                } else if (fill_width < 0) {
                  fill_width = 0;
                }
                if (fill_width > 0) {
                  it.filled_rectangle(x + 2, y + 2, fill_width, inner_height, level_color);
                }
                it.printf(x + icon_width / 2, y + icon_height / 2 + 1, id(font_battery_small), id(black), TextAlign::CENTER, "%.0f%%", percent);
              };

              draw_volume_bar();
              draw_battery_icon();
        - id: answeringP
          lambda: |-
              it.image(0, 0, id(AIm));
              it.rectangle(20 , 24 , 280 , 30 , Color::BLACK );
              it.printf(30, 25, id(font_request), Color::BLACK, "%s", id(text_request).state.c_str());
              it.rectangle(20 , 190 , 280 , 30 , Color::BLACK );
              it.printf(30, 195, id(font_response), Color::BLACK, "%s", id(text_response).state.c_str());
              auto draw_volume_bar = [&]() {
                if (!id(volume_display_active)) {
                  return;
                }
                float display_volume = id(Vol);
                if (id(mute) || id(auto_mute_active)) {
                  display_volume = 0.0f;
                }
                if (display_volume < 0.0f) {
                  display_volume = 0.0f;
                }
                if (display_volume > 1.0f) {
                  display_volume = 1.0f;
                }
                const int gauge_height = 18;
                const int margin = 3;
                const int display_width = it.get_width();
                const int display_height = it.get_height();
                if (display_width <= margin * 2 || display_height <= gauge_height) {
                  return;
                }
                const int gauge_y = display_height - gauge_height;
                const int inner_width = display_width - margin * 2;
                const int inner_height = gauge_height - margin * 2;
                int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
                if (filled_width > inner_width) {
                  filled_width = inner_width;
                } else if (filled_width < 0) {
                  filled_width = 0;
                }
                it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
                if (inner_height > 0) {
                  if (filled_width > 0) {
                    auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                    it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                  }
                  it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
                }
              };
              auto draw_battery_icon = [&]() {
                const int margin = 4;
                const int icon_width = 34;
                const int icon_height = 14;
                const int cap_width = 4;
                const int vertical_offset = 2;
                const int display_width = it.get_width();
                if (display_width <= icon_width + cap_width + margin * 2) {
                  return;
                }
                const int x = display_width - icon_width - cap_width - margin;
                const int y = margin + vertical_offset;
                const int cap_height = icon_height / 2;
                it.rectangle(x, y, icon_width, icon_height, id(black));
                it.filled_rectangle(x + icon_width, y + (icon_height - cap_height) / 2, cap_width, cap_height, id(black));
                const int inner_width = icon_width - 4;
                const int inner_height = icon_height - 4;
                it.filled_rectangle(x + 2, y + 2, inner_width, inner_height, id(bg_charcoal));
                if (!id(battery_percent).has_state()) {
                  return;
                }
                float percent = id(battery_percent).state;
                if (percent < 0.0f) {
                  percent = 0.0f;
                }
                if (percent > 100.0f) {
                  percent = 100.0f;
                }
                auto level_color = id(lime);
                if (percent < 20.0f) {
                  level_color = id(red);
                } else if (percent < 50.0f) {
                  level_color = id(amber);
                }
                int fill_width = static_cast<int>(inner_width * (percent / 100.0f) + 0.5f);
                if (fill_width > inner_width) {
                  fill_width = inner_width;
                } else if (fill_width < 0) {
                  fill_width = 0;
                } 
                if (fill_width > 0) {
                  it.filled_rectangle(x + 2, y + 2, fill_width, inner_height, level_color);
                }
                it.printf(x + icon_width / 2, y + icon_height / 2 + 1, id(font_battery_small), id(black), TextAlign::CENTER, "%.0f%%", percent);
              };            
              draw_volume_bar();
              draw_battery_icon();
        - id: muteMicP
          lambda: |-
            it.image(0, 0, id(muteMicIm));
            auto draw_volume_bar = [&]() {
              if (!id(volume_display_active)) {
                return;
              }
              float display_volume = id(Vol);
              if (id(mute) || id(auto_mute_active)) {
                display_volume = 0.0f;
              }
              if (display_volume < 0.0f) {
                display_volume = 0.0f;
              }
              if (display_volume > 1.0f) {
                display_volume = 1.0f;
              }
              const int gauge_height = 18;
              const int margin = 3;
              const int display_width = it.get_width();
              const int display_height = it.get_height();
              if (display_width <= margin * 2 || display_height <= gauge_height) {
                return;
              }
              const int gauge_y = display_height - gauge_height;
              const int inner_width = display_width - margin * 2;
              const int inner_height = gauge_height - margin * 2;
              int filled_width = static_cast<int>(inner_width * display_volume + 0.5f);
              if (filled_width > inner_width) {
                filled_width = inner_width;
              } else if (filled_width < 0) {
                filled_width = 0;
              }
              it.filled_rectangle(0, gauge_y, display_width, gauge_height, id(bg_charcoal));
              if (inner_height > 0) {
                if (filled_width > 0) {
                  auto bar_color = id(volume_display_active) ? id(lime) : id(light_blue);
                  it.filled_rectangle(margin, gauge_y + margin, filled_width, inner_height, bar_color);
                }
                it.rectangle(margin, gauge_y + margin, inner_width, inner_height, id(black));
              }
            };
            auto draw_battery_icon = [&]() {
              const int margin = 2;
              const int icon_width = 30;
              const int icon_height = 10;
              const int cap_width = 4;
              const int vertical_offset = 2;
              const int display_width = it.get_width();
              if (display_width <= icon_width + cap_width + margin * 2) {
                return;
              }
              const int x = display_width - icon_width - cap_width - margin;
              const int y = margin + vertical_offset;
              const int cap_height = icon_height / 2;
              it.rectangle(x, y, icon_width, icon_height, id(black));
              it.filled_rectangle(x + icon_width, y + (icon_height - cap_height) / 2, cap_width, cap_height, id(black));
              const int inner_width = icon_width - 4;
              const int inner_height = icon_height - 4;
              it.filled_rectangle(x + 2, y + 2, inner_width, inner_height, id(bg_charcoal));
              if (!id(battery_percent).has_state()) {
                return;
              }
              float percent = id(battery_percent).state;
              if (percent < 0.0f) {
                percent = 0.0f;
              }
              if (percent > 100.0f) {
                percent = 100.0f;
              }
              auto level_color = id(lime);
              if (percent < 20.0f) {
                level_color = id(red);
              } else if (percent < 50.0f) {
                level_color = id(amber);
              }
              int fill_width = static_cast<int>(inner_width * (percent / 100.0f) + 0.5f);
              if (fill_width > inner_width) {
                fill_width = inner_width;
              } else if (fill_width < 0) {
                fill_width = 0;
              }
              if (fill_width > 0) {
                it.filled_rectangle(x + 2, y + 2, fill_width, inner_height, level_color);
              }
              it.printf(x + icon_width / 2, y + icon_height / 2 + 1, id(font_battery_small), id(black), TextAlign::CENTER, "%.0f%%", percent);
            };

            draw_volume_bar();
            draw_battery_icon();



# Home Assistant Components
sensor:
  - platform: rotary_encoder
    name: "Volume"
    id: volume_encoder
    pin_a:
      number: GPIO42
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO3
      mode:
        input: true
        pullup: true
    on_anticlockwise:
      then:
        - script.execute:
            id: adjust_volume
            delta: -0.05
    on_clockwise:
      then:
        - script.execute:
            id: adjust_volume
            delta: 0.05
  - platform: rotary_encoder
    name: "Dummy"
    id: function_encoder
    pin_a:
      number: GPIO7
      mode:
        input: true
        pullup: true
    pin_b:
      number: GPIO6
      mode:
        input: true
        pullup: true
    on_anticlockwise:
      then:
        - light.turn_on: screen_backlight
        - lambda: |-
                id(lightTO) = 0;

    on_clockwise:
      then:
        - light.turn_on: screen_backlight
        - lambda: |-
                id(lightTO) = 0;
  - platform: adc
    id: button_adc
    pin: GPIO1
    attenuation: auto
    update_interval: .1s
    on_value_range:
      - above: 3.0
        then:
          - binary_sensor.template.publish:
              id: btn_confirm
              state: OFF
          - binary_sensor.template.publish:
              id: btn_1
              state: OFF
          - binary_sensor.template.publish:
              id: btn_2
              state: OFF
          - binary_sensor.template.publish:
              id: btn_3
              state: OFF
      - above: 0.41
        below: 0.45
        then:
          - binary_sensor.template.publish:
              id: btn_3
              state: ON
      - above: 0.8
        below: 0.84
        then:
          - binary_sensor.template.publish:
              id: btn_confirm
              state: ON
      - above: 1.50
        below: 1.61
        then:
          - binary_sensor.template.publish:
              id: btn_1
              state: ON
      - above: 1.98
        below: 2.03
        then:
          - binary_sensor.template.publish:
              id: btn_2
              state: ON
  - platform: adc
    pin: GPIO13
    name: Battery voltage
    device_class: voltage
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state_class: measurement
    entity_category: diagnostic
    update_interval: 15s
    attenuation: auto
    filters:
      - multiply: 2
      - calibrate_linear:
          - 0.0 -> 0.0
          # Map measured full charge to real value to compensate divider/ADC bias
          - 4.58 -> 4.20
      - exponential_moving_average:
             alpha: 0.2
             send_every: 2
      - delta: 0.002
    on_value:
        then:
          - sensor.template.publish:
              id: battery_percent
              state: !lambda "return x ;"
          - lambda: |-
              if (id(myDisplay).is_ready()) {
                id(myDisplay).update();
              }
  - platform: template
    name: Battery
    id: battery_percent
    device_class: battery
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    entity_category: diagnostic
    update_interval: 15s
    filters:
         - calibrate_polynomial:
              degree: 3
              datapoints:
                  - 4.20 -> 100.0
                  - 4.13 -> 97.1
                  - 4.10 -> 94.2
                  - 4.07 -> 88.4
                  - 4.05 -> 82.7
                  - 4.04 -> 76.9
                  - 4.04 -> 71.1
                  - 4.01 -> 65.3
                  - 3.99 -> 59.5
                  - 3.95 -> 53.8
                  - 3.93 -> 48.0
                  - 3.91 -> 42.2
                  - 3.88 -> 36.4
                  - 3.86 -> 30.6
                  - 3.84 -> 24.9
                  - 3.82 -> 19.1
                  - 3.76 -> 13.3
                  - 3.73 -> 10.4
                  - 3.70 -> 7.5
                  - 3.64 -> 4.6
                  - 3.50 -> 1.7
                  - 3.00 -> 0.0
         - lambda: return clamp(x, 0.0f, 100.0f);   


binary_sensor:
  - platform: gpio
    pin:
      number: GPIO10
      mode:
        input: true
        pullup: true
    id: jack_detect
    name: Jack Detect
    internal: true
    on_press:
      - script.execute: jack_detect_high
    on_release:
      - script.execute: jack_detect_low
  - platform: gpio
    pin:
      number: GPIO48
      inverted: true
      mode:
        input: true
        pullup: true
    id: click_vol
    name: Mute
#    disabled_by_default: true
    on_press:
      then:
        - script.execute: mute_unmute

  - platform: gpio
    pin:
      number: GPIO45
      inverted: true
      mode:
        input: true
        pullup: true
    id: click_sta
    name: Assist
    on_click:
       then:
          script.execute: go_assist


  - platform: template
    name: "Radio 4"
    id: btn_confirm
    on_press:
       - logger.log: "Radio 4 button pressed"


  - platform: template
    name: "Radio 1"
    id: btn_1
    on_press:
       - logger.log: "Radio 1 button pressed"


  - platform: template
    name: "Radio 2"
    id: btn_2
    on_press:
       - logger.log: "Radio 2 button pressed"


  - platform: template
    name: "Radio 3"
    id: btn_3
    on_press:
       - logger.log: "Radio 3 button pressed"
  - platform: remote_receiver
    name: "IR OK"
    id: ir_ok
    nec:
      address: 0xFE01
      command: 0xF906
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR OK received"
  - platform: remote_receiver
    name: "IR UP"
    id: ir_up
    nec:
      address: 0xFE01
      command: 0xFA05
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR UP received"
  - platform: remote_receiver
    name: "IR DOWN"
    id: ir_down
    nec:
      address: 0xFE01
      command: 0xFB04
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR DOWN received"
  - platform: remote_receiver
    name: "IR RIGHT"
    id: ir_right
    nec:
      address: 0xFE01
      command: 0xF50A
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR RIGHT received"
  - platform: remote_receiver
    name: "IR LEFT"
    id: ir_left
    nec:
      address: 0xFE01
      command: 0xFD02
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR LEFT received"
  - platform: remote_receiver
    name: "IR LIKE"
    id: ir_like
    nec:
      address: 0xFE01
      command: 0xF40B
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR LIKE received"
  - platform: remote_receiver
    name: "IR HOME"
    id: ir_home
    nec:
      address: 0xFE01
      command: 0xFC03
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR HOME received"
  - platform: remote_receiver
    name: "IR BIN"
    id: ir_bin
    nec:
      address: 0xFE01
      command: 0xBB44
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR BIN received"  
  - platform: remote_receiver
    name: "IR RESET"
    id: ir_reset
    nec:
      address: 0xFE01
      command: 0xFE00
    filters:
      - delayed_off: 100ms
    on_press:
      - logger.log: "IR RESET received"   

switch:
  - platform: template
    id: mic_mute_switch
    name: "Microphone Mute"
    icon: "mdi:microphone-off"
    entity_category: config
    lambda: |-
      return id(mic_muted);
    turn_on_action:
      - microphone.mute: radio_mic
      - lambda: id(mic_muted) = true;
      - if:
          condition:
            voice_assistant.is_running:
          then:
            - voice_assistant.stop:
      - micro_wake_word.stop:
      - script.execute: reset_display
    turn_off_action:
      - microphone.unmute: radio_mic
      - lambda: id(mic_muted) = false;
      - micro_wake_word.start:
      - script.execute: reset_display

select:
  - platform: template
    name: "Wake word sensitivity"
    optimistic: true
    initial_option: Slightly sensitive
    restore_value: true
    entity_category: config
    options:
      - Slightly sensitive
      - Moderately sensitive
      - Very sensitive
    on_value:
      # Sets specific wake word probabilities computed for each particular model
      # Note probability cutoffs are set as a quantized uint8 value, each comment has the corresponding floating point cutoff
      # False Accepts per Hour values are tested against all units and channels from the Dinner Party Corpus.
      # These cutoffs apply only to the specific models included in the firmware: okay_nabu@20241226.3, hey_jarvis@v2, hey_mycroft@v2
      lambda: |-
        if (x == "Slightly sensitive") {
          id(okay_nabu).set_probability_cutoff(217);    // 0.85 -> 0.000 FAPH on DipCo (Manifest's default)
          id(hey_jarvis).set_probability_cutoff(247);   // 0.97 -> 0.563 FAPH on DipCo (Manifest's default)
          id(hey_mycroft).set_probability_cutoff(253);  // 0.99 -> 0.567 FAPH on DipCo
        } else if (x == "Moderately sensitive") {
          id(okay_nabu).set_probability_cutoff(176);    // 0.69 -> 0.376 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(235);   // 0.92 -> 0.939 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(242);  // 0.95 -> 1.502 FAPH on DipCo (Manifest's default)
        } else if (x == "Very sensitive") {
          id(okay_nabu).set_probability_cutoff(143);    // 0.56 -> 0.751 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(212);   // 0.83 -> 1.502 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(237);  // 0.93 -> 1.878 FAPH on DipCo
        }

text_sensor:
  - id: text_request
    platform: template
    on_value:
      lambda: |-
        if(id(text_request).state.length()>40) {
          std::string name = id(text_request).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),39);
          id(text_request).state = (truncated+"...").c_str();
        }

  - id: text_response
    platform: template
    on_value:
      lambda: |-
        if(id(text_response).state.length()>32) {
          std::string name = id(text_response).state.c_str();
          std::string truncated = esphome::str_truncate(name.c_str(),31);
          id(text_response).state = (truncated+"...").c_str();
        }





#########
# Scripts

script:

  - id: go_reset
    then:
      - lambda: id(bt_restart).press();

  - id: go_assist
    then:
        - light.turn_on: screen_backlight
        - lambda: |-
            id(lightTO) = 0;
        - if:
            condition:
              lambda: 'return(id(phase) == 3 || id(phase) == 4);'
            then:
              - if:
                  condition:
                    voice_assistant.is_running:
                  then:
                    - voice_assistant.stop:
                    - wait_until:
                        not:
                          voice_assistant.is_running:
              - if:
                  condition:
                    media_player.is_announcing:
                  then:
                    - media_player.stop:
                        id: speaker_media_player
                        announcement: true
              - if:
                  condition:
                    media_player.is_playing:
                  then:
                    - media_player.stop:
                        id: speaker_media_player
              - micro_wake_word.start:
              - lambda: |-
                  id(mute) = false;
                  id(auto_mute_active) = false;
                  id(phase) = 1;
              - script.execute: reset_display
            else:
              - if:
                  condition:
                    media_player.is_announcing:
                  then:
                    - media_player.stop:
                        id: speaker_media_player
                        announcement: true
              - if:
                  condition:
                    media_player.is_playing:
                  then:
                    - media_player.stop:
                        id: speaker_media_player
              - if:
                  condition:
                    voice_assistant.is_running:
                  then:
                    - voice_assistant.stop:
                    - wait_until:
                        not:
                          voice_assistant.is_running:
              - micro_wake_word.stop:
              - lambda: |-
                  id(phase) = 3;
              - script.execute: reset_display
              - voice_assistant.start:

  - id: mute_unmute
    then:
        - light.turn_on: screen_backlight
        - lambda: |-
            id(lightTO) = 0;
        - if:
            condition:
              lambda: 'return id(mute);'
            then:
              - logger.log: "unmute!"
              - media_player.volume_set:
                  volume: !lambda 'return id(Vol);'
              - lambda: id(mute) = false;
              - lambda: id(auto_mute_active) = false;
            else:
              - logger.log: "mute!"
              - media_player.volume_set:
                  volume: '0'
              - lambda: id(mute) = true;
              - lambda: id(auto_mute_active) = false;
        - lambda: |-
            id(volume_display_active) = true;
            id(volume_display_timer) = 0;
        - script.execute: schedule_volume_update
        - script.execute: reset_display    

  - id: jack_detect_high
    then:
       - logger.log: "Jack detect high -> route to speaker"
       - output.turn_off: dac_mute
       - lambda: |-
           id(my_es8388).write_byte(0x1D, 0x20);
           id(my_es8388).write_byte(0x1C, 0x10);
           id(my_es8388).write_byte(0x04, 0x30);

  - id: jack_detect_low
    then:
       - logger.log: "Jack detect low -> route to line out"
       - output.turn_on: dac_mute
       - lambda: |-
           id(my_es8388).write_byte(0x1D, 0x00);
           id(my_es8388).write_byte(0x1C, 0x00);
           id(my_es8388).write_byte(0x04, 0x0C);

  - id: adjust_volume
    mode: parallel
    parameters:
      delta: float
    then:
      - light.turn_on: screen_backlight
      - lambda: |-
          id(lightTO) = 0;
          id(Vol) += delta;
          if (id(Vol) < 0) id(Vol) = 0;
          if (id(Vol) > 1) id(Vol) = 1;
          id(volume_display_active) = true;
          id(volume_display_timer) = 0;
          id(mute) = false;
      - media_player.volume_set:
          id: speaker_media_player
          volume: !lambda return id(Vol);
      - delay: 400ms
      - script.execute: schedule_volume_update
      - script.execute: reset_display

  - id: schedule_volume_update
    mode: restart
    then:
      - delay: 400ms
      - lambda: |-
          if (id(volume_display_active) && id(myDisplay).is_ready()) {
            id(myDisplay).update();
          }

  - id: reset_display
    mode: restart
    then: 
       - logger.log: "===> reset_display" 
       - lambda: |-
            id(lightTO) = 0;
            if (id(mic_muted)) {
              id(myDisplay).show_page(muteMicP);
              id(myDisplay).update();
              return;
            }

            if ((id(phase) == 0) && (!id(logo).is_running())) {
              id(logo).execute();
            } else if (id(phase) == 1) {
              id(waiting).execute();
            } else if (id(phase) == 2) {
              id(external_player).execute();
            } else if (id(phase) == 3) {
              id(listening).execute();
            } else if (id(phase) == 4) {
              id(answering).execute();
            }

  - id: logo
    then:
       - logger.log: "===> logo"
       - media_player.speaker.play_on_device_media_file:
           media_file: little_sound
           announcement: false
       - lambda: |-
           id(myDisplay).show_page(logoP);
           id(myDisplay).update();
           id(lightTO) = 0;
       - light.turn_on: screen_backlight
       - delay: 8sec
       - lambda: id(phase) = 1;
       - script.execute: reset_display

  - id: waiting
    mode: restart
    then:
               - if:
                   condition:
                         voice_assistant.is_running:
                   then:
                      - delay: 1s
                      - voice_assistant.stop:
               - script.execute: mute_on
               - micro_wake_word.start:
               - logger.log: "===> wakeword"
               - lambda: |-
                   id(myDisplay).show_page(waitingP);
                   id(myDisplay).update();
                   id(lightTO) = 0;
               - light.turn_on: screen_backlight


  - id: listening
    mode: restart
    then:
       - logger.log: "===> listening"
       - script.execute: mute_on
       - lambda: |-
            id(myDisplay).show_page(listeningP);
            id(myDisplay).update();
            id(lightTO) = 0;

       - light.turn_on: screen_backlight


  - id: answering
    mode: restart
    then:
       - logger.log: "===> answering"
       - script.execute: mute_off
       - lambda: |-
            id(myDisplay).show_page(answeringP);
            id(myDisplay).update();
            id(lightTO) = 0;
       - light.turn_on: screen_backlight
       - delay: 10s




  - id: external_player
    mode: restart
    then:
       - logger.log: "===> front end player"
#       - script.execute: mute_off
       - lambda: |-
            id(myDisplay).show_page(waitingBP);
            id(myDisplay).update();
            id(lightTO) = 0;
       - light.turn_on: screen_backlight

  - id: mute_on
    then:
      - if:
          condition:
            lambda: 'return !id(auto_mute_active);'
          then:
            - media_player.volume_set:
                volume: '0'
      - lambda: |-
          id(mute) = true;
          id(auto_mute_active) = true;
          id(volume_display_active) = true;
          id(volume_display_timer) = 0;
      - script.execute: schedule_volume_update

  - id: mute_off
    then:
      - if:
          condition:
            lambda: 'return id(auto_mute_active);'
          then:
            - media_player.volume_set:
                volume: !lambda return(id(Vol));
      - lambda: |-
          id(mute) = false;
          id(auto_mute_active) = false;
          id(volume_display_active) = true;
          id(volume_display_timer) = 0;
      - script.execute: schedule_volume_update
      
     

button:
  - platform: restart
    id: bt_restart
    name: bt_restart 
      
      
      
      
